<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Thought for your thoughts</title>
		<link>https://ludvigknutsmark.github.io/posts/</link>
		<description>Recent content in Posts on Thought for your thoughts</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 04 Nov 2019 10:45:09 +0100</lastBuildDate>
		<atom:link href="https://ludvigknutsmark.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Blockchains and cryptography: introduction</title>
			<link>https://ludvigknutsmark.github.io/posts/blockchain/</link>
			<pubDate>Mon, 04 Nov 2019 10:45:09 +0100</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/blockchain/</guid>
			<description>I felt like continuing with the buzzwords run, and also learn something completely new. So today I&amp;rsquo;m gonna talk a little bit about on how blockchains actually work, and write some psuedo-code.
What is a blockchain? From Wikipedia -
A blockchain is a growing list of records, called blocks, that are linked using cryptography. Each block contains a cryptographic hash of the previous block, a timestamp, and transaction data.  This wasn&amp;rsquo;t complicated at all.</description>
			<content type="html"><![CDATA[

<p>I felt like continuing with the buzzwords run, and also learn something completely new. So today I&rsquo;m gonna talk a little bit about on how blockchains actually work, and write some psuedo-code.</p>

<h2 id="what-is-a-blockchain">What is a blockchain?</h2>

<p>From <a href="https://en.wikipedia.org/wiki/Blockchain" target="_blank">Wikipedia</a> -</p>

<pre><code>A blockchain is a growing list of records, called blocks, that are linked using cryptography.
Each block contains a cryptographic hash of the previous block, a timestamp, and transaction data.
</code></pre>

<p>This wasn&rsquo;t complicated at all. Simply a linked list where the integrity and order of the blocks is controlled by an hashing algorithm(H).</p>

<pre><code> ____      ____      ____
| G  |    | A  |    | B  | *n
|    |---&gt;|H(G)|---&gt;|H(A)|---&gt;
|data|    |data|    |data|
|____|    |____|    |____|

</code></pre>

<p>The implication of this is that if an attacker would change an arbitrary block in the chain, he would then need to change all blocks after that block in order for the chain to be correct. Most blockchains is managed in a peer-to-peer network, which means that the attacker, without network majority, cannot control the entire chain after the changed block. Simply, the chain is copied to each peer in the network and only trusts the majority. If the attacker would change a block and his copy of the chain, the network would vote on which copy is correct, and choose the majority&rsquo;s copy.</p>

<p>(This is the basic idea of a decentralized blockchain, but there are other types of blockchain which have different voting algorithms or other models in which the former statement doesn&rsquo;t hold true. The voting/majority part that is. Thanks to Hampus Bengtsson for pointing that out).</p>

<h2 id="introducing-new-transactions-blocks-into-the-chain">Introducing new transactions(blocks) into the chain</h2>

<p>To prevent the chain from overflowing with blocks we must ensure that it&rsquo;s a hard problem to add new blocks to the chain. This is very important in cryptocurrencies i.e. Bitcoin. This is what&rsquo;s called mining. Mining comes from the parable with mining gold(or other metals). We add more money into the economy. If anyone could add coins into the chain very easily we would have a <a href="https://en.wikipedia.org/wiki/Hyperinflation_in_the_Weimar_Republic" target="_blank">Weimar hyperinflation</a> all over again. That&rsquo;s why any new block needs a proof-of-work which is very hard to calculate. A commonly used proof-of-work is that the hash of every block must start with x-numbers of zero.</p>

<pre><code>class Block():
	def __init__(self, id, data, prev_hash=None):
		self.id = id
		self.data = data
		self.prev_hash = prev_hash
		self.nonce = 0
	
	def mine(self, x=4):
		while hash(self)[:x] != &quot;0&quot;*x:
			self.nonce += 1

		self.hash = hash(self)
		return

	def dump(self):
		if self.hash is None:
			self.mine()

		return {
			&quot;id&quot;:id,
			&quot;data&quot;: self.data,
			&quot;timestamp&quot;: time.now(),
			&quot;nonce&quot;: self.nonce,
			&quot;prev_hash&quot;=self.prev_hash
		}
</code></pre>

<p><em>If you for some reason would want the code to actually work - change the hash-call to a real hashing algorithm, and make the time.now() call to a string</em></p>

<p>A simple block class which holds transaction data and the hash of the parent. If we would like to add a new block to our chain we would simply do (note that block.dump() calls on block.mine() if the block is not mined yet)</p>

<pre><code># Initialize with genesis block
chain = []
genesis = Block(id=0, data={XXXX}) # prev_hash=None
chain.append(genesis.dump())

# Add a new block to the chain
new_block = Block(id=1, data={xxxxx}, prev_hash=genesis.hash)
chain.append(new_block.dump())
</code></pre>

<p>As you can see blockchains are actually very simple in it&rsquo;s basic form, but there are so many variants on every algorithm and voting policies and so forth that there could be thousands of books to cover the complete topic. This was only a fairly quick reading to learn the basics about blockchains.</p>

<h2 id="attacking-blockchains">Attacking blockchains</h2>

<p>In this basic form of the blockchain the only attack vector would be to take majority of the network to change the transaction data in any block successfully. As mentioned above, every blockchain has it&rsquo;s own algorithms and forms, and therefore new attack vectors.</p>

<h2 id="conclusion">Conclusion</h2>

<p>There a million of blog posts like this that are much better and more thourough, I only wrote this since I wanted to know how basic blockchains work and to learn something new. I guess next post will be on how to build a CAN-network with arduinos :) Or maybe a crypto-attack</p>
]]></content>
		</item>
		
		<item>
			<title>Homomorphic encryption</title>
			<link>https://ludvigknutsmark.github.io/posts/homomorphic/</link>
			<pubDate>Sun, 03 Nov 2019 16:19:16 +0100</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/homomorphic/</guid>
			<description>Today I&amp;rsquo;m gonna talk a bit about a cool buzzword in the crypto world - Homomorphic Encryption. What is it and how does it really work? And maybe more important, why do we want this?
Homomorphism Homomorphism is defined in a mathematical set such as the result of an operation is mirrored in another set by performing the same operation in that set.
$f:G\rightarrow H$ where $f(xy)=f(x)f(y)$
Oh yes, I finally took the time to integrate LaTeX into Hugo.</description>
			<content type="html"><![CDATA[

<p>Today I&rsquo;m gonna talk a bit about a cool buzzword in the crypto world - Homomorphic Encryption. What is it and how does it really work? And maybe more important, why do we want this?</p>

<h2 id="homomorphism">Homomorphism</h2>

<p>Homomorphism is defined in a mathematical set such as the result of an operation is mirrored in another set by performing the same operation in that set.</p>

<p>$f:G\rightarrow H$ where $f(xy)=f(x)f(y)$</p>

<p><em>Oh yes, I finally took the time to integrate LaTeX into Hugo. No more ugly x^2 equations.</em></p>

<p>In the context of cryptography this means that the result of an operation performed on the ciphertext(G) is mirrored when the same operation is performed on the plaintext(H).</p>

<p>For example, given a ciphertext $\mathit{C}$ and a plaintext $\mathit{P}$, with an operation $\star$ the following holds true in a fully* homomorphic scheme.</p>

<p>$$C&rsquo;=x\star C$$
$$P&rsquo;=decrypt(C&rsquo;)$$
$$P=x\star^{-1} P&rsquo;$$</p>

<p>where $\mathit{x}$ can be any argument to the operation.</p>

<p>There are basically three types of homomorphic encryption. (1) Partially homomorphic encryption(PHE), this allows one type of operation, (2) Somewhat homomorphic encryption (SWHE) which allows some types of operations and (3) Fully homomorphic encryption (FHE) which allows all operations.</p>

<h2 id="black-magic">Black magic</h2>

<p>This does sound like black magic. Actually RSA is a homomorphic encryption-scheme (PHE). RSA allows unlimited amount of modular multiplications.</p>

<p>$$C = P^{e} \mod n$$
$$C&rsquo;= C\times x^{e} \mod n$$
$$P&rsquo;=C&rsquo;^{d} \mod n$$
$$P=\frac{P&rsquo;}{x} \mod n$$</p>

<p>Because</p>

<p>$$P&rsquo;=C&rsquo;^{d}=(C\times x^{e})^{d}=(P^{e}\times x^{e})^{d}=Px^{ed}=Px \mod n$$</p>

<p>Remember that</p>

<p>$$ed = 1 \mod n$$</p>

<p>This allows one type of operation (modular multiplication) on the ciphertexts. But there actually exists a scheme which allows any operation on the ciphertext, a fully homomorphic encryption-scheme. It&rsquo;s called <a href="https://crypto.stanford.edu/craig/craig-thesis.pdf" target="_blank">Gentry&rsquo;s FHE</a>.</p>

<h2 id="but-when-could-this-be-useful">But when could this be useful?</h2>

<p>A obvious application is cloud services. In a traditional cloud service where we hold sesitive encrypted data, the cloud provider owns both the encrypted data and the method to encrypt (and decrypt) the data. Now say an attacker takes control of the cloud service, he owns the encrypted data, and also the means to decrypt it. If we could employ a homomorphic encryption-scheme, the cloud provider can outsource the encryption and decryption methods to the original owner of the data. The cloud provider now only has the encrypted data but can still perform any operation (statisics, sorting, querys etc.) and so on. If an attacker now takes control of the cloud service, he only has control of the encrypted data, which in that form is worthless.</p>

<p>Often when there is talk about homomorphic encryption, some people often mention encrypted databases. Encrypted databases is almost always a bad idea. <a href="https://blog.cryptographyengineering.com/2019/02/11/attack-of-the-week-searchable-encryption-and-the-ever-expanding-leakage-function/" target="_blank">Matthew Green has an awesome article about this</a>. Looks like with a sufficent amount of querys an attacker can reconstruct parts of the database. Oops!</p>

<h2 id="conclusion">Conclusion</h2>

<p>This is of course super interesting, and is seen like the holy grail of cryptography. Today there exists a fully homomorphic scheme, but it suffers from really serious performance issues. We are probably a long time away from a applicable FHE-scheme.</p>

<p>If you found this interesting. Me and a classmate Johan Näslund, wrote a short paper about homomorphic encryption. You can find it <a href="https://drive.google.com/open?id=130Yp4bPsO1DHmMyZnh9Q8yToU5_Q_IBO" target="_blank">here</a> (Swedish).</p>
]]></content>
		</item>
		
		<item>
			<title>You sure can quant on me!</title>
			<link>https://ludvigknutsmark.github.io/posts/postquantom/</link>
			<pubDate>Sat, 02 Nov 2019 09:33:15 +0100</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/postquantom/</guid>
			<description>So, I recently treated myself with a Nintendo switch. Let&amp;rsquo;s say computer time has been limited lately&amp;hellip;Saving Hyrule has been kind of my priority :)
I recently took a course called Kryptering 3 (advanced cryptography), which mostly is about post-quantom cryptography and the corresponding algorithms. Yesterday I fell into some writing mode again, so today I&amp;rsquo;m gonna talk a bit about quantom computers and show a &amp;ldquo;quantom safe&amp;rdquo; algorithm - GGH.</description>
			<content type="html"><![CDATA[

<p>So, I recently treated myself with a Nintendo switch. Let&rsquo;s say computer time has been limited lately&hellip;Saving Hyrule has been kind of my priority :)</p>

<p>I recently took a course called Kryptering 3 (advanced cryptography), which mostly is about post-quantom cryptography and the corresponding algorithms. Yesterday I fell into some writing mode again, so today I&rsquo;m gonna talk a bit about quantom computers and show a &ldquo;quantom safe&rdquo; algorithm - GGH.</p>

<h2 id="what-is-quantom-computers-and-why-you-should-care">What is Quantom computers and why you should care</h2>

<p>A regular computer has it&rsquo;s lowest information represented as a bit, one or zero. A quantom computer has its lowest information represented as a qubit. Reading a qubit is different from reading a bit. A bit is always one or zero, but a qubit is represented as a normalized superposition of either one or zero (this is black magic). This gives quantom computers special properties, which in short makes quantom computers incredibly fast at solving specific problems. Or rather, given this quantom property we can construct specific algorithms which utilizes these to solve specific problems. You may have heard about one of these algorithms - Shor&rsquo;s algorithm.</p>

<p>A common myth is that quantom computers breaks all encryption. This is not true. Rather shor&rsquo;s algorithm (in theory) solves the integer factorization and discrete logarithm problem in polynomial time.</p>

<p>What does this mean then? Well, the encryption schemes which builds on these problems are broken with suffiently good quantom computers. Any schemes that comes to mind? How about RSA, ECDSA and Diffie-Hellman? Which all are asymmetric algorithms. Symmetric algorithms (like AES) seems to be fine for now, i.e. there is no quantom algorithm which breaks these like Shor&rsquo;s algorithm breaks some asymmetric schemes.</p>

<h3 id="cool-and-all-but-this-sounds-like-real-sci-fi-i-shouldn-t-care-right">Cool and all, but this sounds like real sci-fi. I shouldn&rsquo;t care right?</h3>

<p><a href="https://www.theverge.com/2019/10/23/20928294/google-quantum-supremacy-sycamore-computer-qubit-milestone" target="_blank">Google just declared quatom supremacy</a> and earlier this year Martin Ekerå and Craig Gidney wrote a paper which described how to factor <a href="https://arxiv.org/pdf/1905.09749.pdf" target="_blank">2048-bit RSA integers in 8 hours</a>.</p>

<p><img src="https://media.giphy.com/media/WrK9dwj8TNPr2/giphy.gif" alt="alt text" /></p>

<p>Such quantom computers are not here yet though. But according to Martin Ekerå - they can be in the next 10-25 years.</p>

<h3 id="ahhh-everythings-on-fire">Ahhh, everythings on fire!!</h3>

<p>Well, this sucks :D But don&rsquo;t worry too much just yet, there are solutions to this.</p>

<p>So, Shor&rsquo;s algorithm solves the integer factorization and discrete logarithm problem in polynomial time. Can we build asymmetric schemes which depends on other problems? Looks like we can!</p>

<h2 id="ggh-and-don-t-use-this">GGH (and don&rsquo;t use this)</h2>

<p>A fairly simple algorithm (compared to other post-quantom schemes) is GGH. It is broken though, so don&rsquo;t use it. But it&rsquo;s easier than others to explain.</p>

<h3 id="math-math-and-math">Math, math and math</h3>

<h4 id="vector-space">Vector space</h4>

<p>First we need to have something called vector space. A vectorspace V over R is defined if V is closed under addition and multiplication for all vectors in V and elements i R. This means that the result of adding two arbitrary vectors from V is in V, and the scalar multiplication of an arbitrary vector in V and element in R is in V. It&rsquo;s easier to show -</p>

<pre><code>u,v in V
a in R

u+v in V
au in V
</code></pre>

<p>There are more rules to this (read my other posts).</p>

<p>A vectorspace V has a base B=(v1,v2,&hellip;,vm) if B is linearly independant and every vector, v can be written like a linear combination of B.</p>

<h4 id="lattice">Lattice</h4>

<p>A Lattice is a vector space with a base (linearly independant vectors) which generates the lattice.</p>

<p>Example:</p>

<pre><code>L = lattice
(v_1,v_2,...,v_n) = base

Given the base v_1=(1,0) and v_2=(2,1) where v_1,v_2 in R^2 the lattice L is described as

L = {xv1, yv2} = {x+2y, y} for all elements x,y in Z
</code></pre>

<p>The lattice can be represented as all points {x,y} in the plane.</p>

<h4 id="here-comes-the-problem">Here comes the problem</h4>

<p>One problem which is hard to solve (in higher dimensions) is the Closest vector problem. Given a vector w in R, find the closest vector v to w in the vector space V, i.e. find the vector v in V with the shortest distance to w</p>

<h3 id="ggh">GGH</h3>

<h4 id="keys">Keys</h4>

<p>Pick n random linearly independant vectors from Z^n and set the private key</p>

<pre><code>V = (v_1,v_2,...,v_n)^T
</code></pre>

<p>Pick a random matrix U with order n such as determinant U = +-1</p>

<p>Set the public key W to</p>

<pre><code>W = UV
</code></pre>

<h4 id="encryption">Encryption</h4>

<p>The plaintext p should be coded in such a way that p=(p_1,p_2,&hellip;,p_n) is in Z^n.</p>

<p>Pick a random efemary key r in Z^n. I will describe why below.</p>

<p>The ciphertext is then given by</p>

<pre><code>c = pW + r
</code></pre>

<h4 id="decryption">Decryption</h4>

<p>We have a vector c which is not in V. Why not? Because we introduced a noise, r.</p>

<p>To find the original message p we first need to find pW (which is a vector in V). To do this we find the closest vector to c. This means that me remove the noise introduced by r.</p>

<pre><code>pW = solve_CVP(c, V)
p = pWW^-1 = pI = p
</code></pre>

<p>Solving approximate CVP can be done by <a href="http://www.noahsd.com/mini_lattices/05__babai.pdf" target="_blank">Babai&rsquo;s algorithm</a>. But not knowing V (the private key) makes it a really hard problem to solve.</p>

<h2 id="conclusion">Conclusion</h2>

<p>As you can see above, GGH is built on the closest vector problem (and not integer factorization or discrete logarithms). GGH is very broken though! But there are other post-quantom algorithms which work much better (such as McEliece and NTRU).</p>

<p>This was a basic introduction to post-quantom cryptography and why we all should care. Next post will be a introduction to homomorphic encryption (yay, more buzzwords!).</p>
]]></content>
		</item>
		
		<item>
			<title>T H I C C_C U R V E S pt. 2</title>
			<link>https://ludvigknutsmark.github.io/posts/ellipticalcurves_part2/</link>
			<pubDate>Tue, 27 Aug 2019 20:16:18 +0200</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/ellipticalcurves_part2/</guid>
			<description>In part 1 we saw a basic explaination of the math behind elliptical curves (and some python code). In this part I&amp;rsquo;ll explain the ECDSA algorithm (Elliptical Curve Digital Signature Algorithm).
Key generation The keys are based on Diffie-Hellman. It&amp;rsquo;s actually really simple:
def generate_keypair(self): # Diffie-Hellman self.private = randint(1, self.baseorder) self.public = self.multiply(self.private, self.base) A.session_key = A.private*(B.public*base) B.session_key = B.private*(A.public*base)  This works, because of the abelian property associativeness (maybe an english word?</description>
			<content type="html"><![CDATA[

<p>In part 1 we saw a basic explaination of the math behind elliptical curves (and some python code). In this part I&rsquo;ll explain the ECDSA algorithm (Elliptical Curve Digital Signature Algorithm).</p>

<h2 id="key-generation">Key generation</h2>

<p>The keys are based on Diffie-Hellman. It&rsquo;s actually really simple:</p>

<pre><code>def generate_keypair(self): # Diffie-Hellman
        self.private = randint(1, self.baseorder)
        self.public = self.multiply(self.private, self.base)

A.session_key = A.private*(B.public*base)
B.session_key = B.private*(A.public*base)
</code></pre>

<p>This works, because of the abelian property associativeness (maybe an english word?).</p>

<pre><code>a = A.private
b = B.private
A.session_key = a*(b*base) = (a*b)*base = b*(a*base) = B.session_key
</code></pre>

<h2 id="ecdsa-algorithm">ECDSA algorithm</h2>

<p>Wikipedia actually explains the algorithm very well, and why it works. <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank">Take a look</a>.</p>

<p>Python code for the algorithm look like this:</p>

<pre><code>def sign(self, H):
        z = int(&quot;0x&quot;+H, 16)
        k = randint(1,self.baseorder-1)
        P = self.multiply(k,self.base)
        
        if P.x == 0:
            return self.sign(H)
        
        r = P.x
        s = (z+r*self.private)*I_invert(k, self.baseorder)%self.baseorder

        return int(r), int(s)

    def verify_signature(self, signature, pub, H):
        r,s = signature
        if not (1 &lt;= r &lt;= self.baseorder-1 and 1 &lt;= s &lt;= self.baseorder-1):
            raise Exception(&quot;Invalid signature&quot;)

        z = int(&quot;0x&quot;+H, 16)
        u1 = z*I_invert(s,self.baseorder)%self.baseorder
        u2 = r*I_invert(s,self.baseorder)%self.baseorder

        P = self.add(self.multiply(u1,self.base),self.multiply(u2, pub))
        
        if r == P.x:
            return True
        else:
            raise Exception(&quot;Invalid signature&quot;)
</code></pre>

<p>Since I programmed it, I can decide the hashing algorithm, and therefore <em>z</em>. I chose sha1 with regards to the length of the hash.</p>

<p>The complete code can be found at <a href="https://github.com/ludvigknutsmark/shitecurves/blob/master/ec.py" target="_blank">github</a>.</p>

<h2 id="rust-implementation">Rust implementation</h2>

<p>So I&rsquo;ve spent the last day to learn basic Rust and implementing ECDSA. Therefore my implementation may be relativaly bad from a speed perspective. But I think it turned out okay for my first time
writing Rust.</p>

<p>Rust by default do not support the sizes of our parameters, therefore I needed to implement a big-num library (or crate as Rust calls it).</p>

<p>Rust does not support classes either, but like Go, it supports structs. I think this is fine, but it did change my implementation a bit. It now deviates a bit from my Python implementation.</p>

<p>Here&rsquo;s the sign and verify_sign functions.</p>

<pre><code>fn sign(h: &amp;str, private: Integer) -&gt; (Integer, Integer) {
    let base = Point{               
        x: hex2int(&quot;188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012&quot;),
        y: hex2int(&quot;07192b95ffc8da78631011ed6b24cdd573f977a11e794811&quot;),
    };
    let baseorder = hex2int(&quot;ffffffffffffffffffffffff99def836146bc9b1b4d22831&quot;);

    let z = hex2int(h);
    let k = gen_random();
    let P = point_multiply(&amp;k, &amp;base);
    
    if P.x == Integer::from(0) {
        sign(h, private.clone());
    }

    let r = P.x;
    let s = (z+r.clone()*private)*Integer::from(k.invert_ref(&amp;baseorder).unwrap()).rem_floor(&amp;baseorder);

    (r,s)
}

fn verify_signature(signature: (Integer, Integer), public: Point, h: &amp;str) -&gt; bool {
    let base = Point{               
        x: hex2int(&quot;188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012&quot;),
        y: hex2int(&quot;07192b95ffc8da78631011ed6b24cdd573f977a11e794811&quot;),
    };
    let baseorder = hex2int(&quot;ffffffffffffffffffffffff99def836146bc9b1b4d22831&quot;);

    let r = signature.0;
    let s = signature.1;
    
    if 1 &gt; r &amp;&amp; r &gt; baseorder.clone()-Integer::from(1) &amp;&amp; 1 &gt; s &amp;&amp; s &gt; baseorder.clone()-Integer::from(1) {
        panic!(&quot;Invalid signature&quot;);
    }
    
    let z = hex2int(h);
    let u1 = z*Integer::from(s.invert_ref(&amp;baseorder).unwrap()).rem_floor(&amp;baseorder);
    let u2 = r.clone()*Integer::from(s.invert_ref(&amp;baseorder).unwrap()).rem_floor(&amp;baseorder);

    let P = point_add(&amp;point_multiply(&amp;u1, &amp;base), &amp;point_multiply(&amp;u2, &amp;public));
    
    if r == P.x {
      return true
    }

    return false
}
</code></pre>

<p>The complete code can be found at <a href="https://github.com/ludvigknutsmark/shitecurves/blob/master/ecRust/src/main.rs" target="_blank">github</a>.</p>

<h2 id="speed-comparison">Speed comparison</h2>

<p>For each iteration I generate the keys, sign a message and verify the message. I do this 1000 times on each program.</p>

<pre><code># ec.py

for i in range(1000):
        ec = EC(a,b,G,n,p)

        ec.generate_keypair()
     
        H = &quot;719609852b46b8ea9a5fcd39eb7bc9088fa36399&quot;    
        r,s = ec.sign(H)
        ec.verify_signature((r,s), ec.public, H)

</code></pre>

<p>Here are the results.</p>

<pre><code>$ time python ec.py

real	0m8,314s
user	0m7,358s
sys	0m0,033s
</code></pre>

<pre><code>$ time ecRust/target/release/ec_rust

real	0m5,099s
user	0m5,097s
sys	0m0,000s
</code></pre>

<p>So Rust was a bit faster, but not by much. This is probably due to my bad Rust skills and only knowing it for about 24 hours :) I suspect that my implementation can be sped up by a factor or two.</p>

<h2 id="next-time">Next time</h2>

<p>My CAN-buses haven&rsquo;t arrived yet, but when they do I will take a dive into CAN and some cool stuff!</p>
]]></content>
		</item>
		
		<item>
			<title>T H I C C_C U R V E S pt. 1</title>
			<link>https://ludvigknutsmark.github.io/posts/ellipticalcurves/</link>
			<pubDate>Fri, 16 Aug 2019 17:10:39 +0200</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/ellipticalcurves/</guid>
			<description>I&amp;rsquo;m back with small series where I explain the math behind elliptical curve cryptography and write my own implementation in python. As usual this is nothing new or super exciting.
I&amp;rsquo;ve recently ordered some Arduino boards and CAN-buses, so soon I will be taking a deep dive into CAN and car hacking! Making myself ready for our big move to Gothenburg :)
What&amp;rsquo;s an Elliptical curve then? From Wikipedia -</description>
			<content type="html"><![CDATA[

<p>I&rsquo;m back with small series where I explain the math behind elliptical curve cryptography and write my own implementation in python. As usual this is nothing new or super exciting.</p>

<p>I&rsquo;ve recently ordered some Arduino boards and CAN-buses, so soon I will be taking a deep dive into CAN and car hacking! Making myself ready for our big move to Gothenburg :)</p>

<h2 id="what-s-an-elliptical-curve-then">What&rsquo;s an Elliptical curve then?</h2>

<p>From <a href="https://en.wikipedia.org/wiki/Elliptic_curve" target="_blank">Wikipedia</a> -</p>

<pre><code>In mathematics, an elliptic curve is a plane algebraic curve defined by an equation of the form

y^2=x^3+ax+b

which is non-singular; that is, the curve has no cusps or self-intersections.
</code></pre>

<p>Which means that it is non-singular, i.e it has no singular points on the curve. As Wikipedia says - it has no intersection nor cusps.</p>

<p>A cusp is a point where both the tangent of x and y is zero. You can also say that you can decide two tangents in a singular point, where in a non-singular you can only decide one.</p>

<h3 id="quick-maths">Quick maths</h3>

<p>Take P(x1,y1) and Q(x2,y2) where the intersection is non-vertical, the line which intersects P and Q is</p>

<pre><code>(kx+m)^2 = x^3+ax+b
</code></pre>

<p>Which also is a point on the curve.</p>

<p><strong>BUt WhAt iF tHE iNteRsECtiOn iS VerTIcAl</strong></p>

<p>That can happen. Therefore we introduce a point to represent infinity (Since the third point on the line doesn&rsquo;t exist). This will be proven to come in handy later :)</p>

<h3 id="group-theory-as-fields">Group theory as fields</h3>

<p>So, we actually do implement Elliptical curves as fields. This requires some rules -</p>

<ul>
<li><strong>Associative</strong>: (a*b)*c = a*(b*c)</li>
<li><strong>Identity element</strong>: There exists an element, e, which a*e=a</li>
<li><strong>Inverse</strong>:  a*a^-1=e</li>
</ul>

<p>(This is a really basic explaination)</p>

<p>We already defined an identify element (the one to represent infinity, <strong>0</strong>). Nice!</p>

<p>So for our nice elliptical curve, the rules follows as such -</p>

<ul>
<li>(P+Q)+R = P+(Q+R)</li>
<li>P+0 = 0</li>
<li>P+P&rsquo; = 0</li>
<li>P&rsquo;+P&rsquo; = P</li>
</ul>

<h3 id="addition-of-two-points-on-the-curve">Addition of two points on the curve</h3>

<p>So the proof for the addition algorithm is a bit tricky (Read: I&rsquo;m to lazy :D)
But it looks like this -</p>

<p>(P+Q) % p</p>

<ol>
<li>If P=0 (i.e P+0) return Q</li>
<li>If Q=0 (i.e 0+Q) return P</li>
<li>(remember that addition is third point of intersection on the curve between P and Q</li>
</ol>

<pre><code>x = delta^2-x1-x2
y = delta*(x1-x)-y1

delta = 
	if p1=p2: # This means that the point of intersection is the derivative, f'(x) of f(x)
		delta = (3*x1^2+A)  / 2*y1
	else:
		delta = (y2-y1) / (x2-x1)

</code></pre>

<pre><code>*omitted*

def add(self,p1, p2):
        if p1 == self.id:
            return p2

        if p2 == self.id:
            return p1
        
        if p1 == p2.invert(self.p):
            return self.id

        if p1 == p2:
            delta = (3*pow(p1.x,2)+self.A)*gmpy2.invert(2*p1.y, self.p)
        else:
            delta = (p2.y - p1.y)*gmpy2.invert(p2.x - p1.x, self.p)
        
        x = pow(delta, 2)- p1.x - p2.x
        y = delta*(p1.x-x)-p1.y 

        return Point(x % self.p, y % self.p)

*omitted*
</code></pre>

<p>Point is a simple class</p>

<pre><code>class Point():
    def __init__(self,x,y):
        self.x = x
        self.y = y
    
    def __str__(self):
        return &quot;{&quot;+str(self.x)+&quot;, &quot;+str(self.y)+&quot;}&quot;

    def __eq__(self, p2):
        return True if self.x == p2.x and self.y == p2.y else False
    
    def __mod__(self,p):
        return Point(self.x%p, self.y%p)
    
    def invert(self, p):
        return Point(self.x, p-self.y)
</code></pre>

<h3 id="multiplication">Multiplication</h3>

<p>I have actually written the multiplication algorithm for fields already. Check out <a href="https:/ludvigknutsmark.github.io/posts/breaking_aes_gcm_part2/#gcm-and-galois" target="_blank">galois fields</a></p>

<p>So we end up with</p>

<pre><code>*omitted*

def multiply(self,n,p):
        q = self.id
        while n &gt; 0:
            if n&amp;1:
                q = self.add(q,p)
            p = self.add(p,p)
            n = n &gt;&gt; 1
        return q % self.p

*omitted*
</code></pre>

<p>Where n is an integer for the multiplication nP = Q</p>

<h2 id="done-for-today">Done for today</h2>

<p>Now we have everything to set up Elliptical curve cryptography, which I will cover in the next post. Until next time!</p>
]]></content>
		</item>
		
		<item>
			<title>How_to_pizza.jpg</title>
			<link>https://ludvigknutsmark.github.io/posts/howtopizza/</link>
			<pubDate>Wed, 24 Jul 2019 21:53:31 +0200</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/howtopizza/</guid>
			<description>Pizza time! After a well deserved break with 6(!!) days of vacation, I&amp;rsquo;m back! Not really feeling the urge to pick up some new crypto stuff to write about just yet, but &amp;ldquo;den som väntar på något gott&amp;rdquo; :)
This saturday me and my good friend Elin had our joint birthday party.
It all started with a case of beers and a jacuzzi, where we decided to host a party where we cooked Neapolitan pizza for everyone, one pizza each, just like a one-night, pop-up pizza place.</description>
			<content type="html"><![CDATA[

<h1 id="pizza-time">Pizza time!</h1>

<p>After a well deserved break with 6(!!) days of vacation, I&rsquo;m back! Not really feeling the urge to pick up some new crypto stuff to write about just yet, but &ldquo;den som väntar på något gott&rdquo; :)</p>

<p>This saturday me and my good friend Elin had our joint birthday party.</p>

<p>It all started with a case of beers and a jacuzzi, where we decided to host a party where we cooked Neapolitan pizza for everyone, one pizza each, just like a one-night, pop-up pizza place. Since my parents neighbour just happened to have a wood oven in his basement it was maybe not the stupidest idea in the world. Maybe</p>

<h2 id="how-do-i-make-a-good-pizza">How do I make a good pizza?</h2>

<p>You start off with picking the sort of pizza you want to make.</p>

<p>Waiting&hellip;</p>

<p>Correct! Neapolitan style is what you want to do.</p>

<h3 id="the-dough">The dough</h3>

<ol>
<li>Go to <a href="https://www.stadlermade.com/pizza-dough-calculator/" target="_blank">dough calculator</a>. Personally I think 250 grams is a perfect size per pizza.</li>
<li>Mix all of the sea salt and water with a fork until the salt is completely dissolved. Mix in 10 % of the flour (choose a 00 flour, like tipo 00). Mix with a spoon.</li>
<li>Put in all the yeast and mix with a fork until the yeast has dissolved.</li>
<li>Continuosly mix in the rest of the flour just like any other dough. Knead the dough until it&rsquo;s no longer sticky.</li>
<li>Form the dough into dough balls <a href="https://www.youtube.com/watch?v=v5t5MEZt6LM" target="_blank">tutorial</a></li>
<li>Let them work/rest for a minimum of 24 hours.</li>
</ol>

<h3 id="topping">Topping</h3>

<p>Here you can pick whatever you want but we choose:</p>

<ul>
<li><p>Mutti tomatoes which we crushed</p></li>

<li><p>Sea salt</p></li>

<li><p>Black pepper</p></li>

<li><p>Fresh Mozzarella</p></li>

<li><p>Basil</p></li>

<li><p>Olive oil</p></li>

<li><p>Parma ham</p></li>
</ul>

<p>This is the classic Neapolitan margherita (minus the Parma ham).</p>

<h3 id="the-cooking">The Cooking</h3>

<p>The most important part. For the best result you need a wood oven. We had our wood oven running at about 450-500 degrees celsius. A pizza took about 45-50 seconds to cook.</p>

<ol>
<li>Put the kindling in the middle of the oven. Have it burning for about 45 minutes, add more kindling when needed.</li>
<li>Move the kindling away from the stone/middle to the sides. I recommend covering all sides to get a even cooking of the pizza. Let the stone cool a little bit, for about 10 minutes.</li>
<li>Put in the pizza</li>
<li>???</li>
<li>Profit</li>
</ol>

<h2 id="result">Result</h2>

<p><img src="/party_pizza.jpg" alt="image alt text" /></p>

<p><img src="/party_pizza_ham.jpg" alt="image alt text" /></p>

<p><img src="/party.jpg" alt="image alt text" /></p>
]]></content>
		</item>
		
		<item>
			<title>OPAQUE PAKE</title>
			<link>https://ludvigknutsmark.github.io/posts/opaque_pake/</link>
			<pubDate>Wed, 29 May 2019 09:32:04 +0200</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/opaque_pake/</guid>
			<description>Meanwhile as I&amp;rsquo;m stuck at trying to factorize polynomials in GF(2^128), see previous post, I decided to take a look at a new PAKE protocol I saw on twitter.
PAKE PAKE Protocols is a authenticated key exchange protocol. An example of a unauthenticated key exchange protocol is Diffie-Hellman. I&amp;rsquo;ve written code on a very basic MITM-attack on Diffie-Hellman here.
In a PAKE protocol you authenticate through a password - and what makes it really great is that the password is also protected.</description>
			<content type="html"><![CDATA[

<p>Meanwhile as I&rsquo;m stuck at trying to factorize polynomials in GF(2^128), see previous post, I decided to take a look at a new PAKE protocol I saw on twitter.</p>

<h2 id="pake">PAKE</h2>

<p>PAKE Protocols is a authenticated key exchange protocol. An example of a unauthenticated key exchange protocol is Diffie-Hellman. I&rsquo;ve written code on a very basic MITM-attack on Diffie-Hellman
<a href="https://raw.githubusercontent.com/ludvigknutsmark/Cryptopals_Solves/master/set5/challenge34.py" target="_blank">here</a>.</p>

<p>In a PAKE protocol you authenticate through a password - and what makes it really great is that the password is also protected. After a failed attempt the client and server should only know
if the attempt failed or not <strong><em>if the password matched the server&rsquo;s expected value</em></strong>.</p>

<h2 id="why-opaque">Why OPAQUE?</h2>

<p>If you&rsquo;ve heard of Secure Remote Password, or SRP, you may know that it&rsquo;s like OPAQUE, a PAKE protocol. SRP has some issues, for instance it allows an attacker to run an offline-dictionary attack,
since it exposes the salt to the user. I&rsquo;ve written some code on the attack <a href="https://raw.githubusercontent.com/ludvigknutsmark/Cryptopals_Solves/master/set5/challenge38.py" target="_blank">here</a></p>

<p>So, OPAQUE&hellip; OPAQUE does not reveal the salt to the user, nor does it reveal the password to the server. It does this by having the server and the client run an oblivious <a href="https://en.wikipedia.org/wiki/Pseudorandom_function_family" target="_blank">PRF</a>.</p>

<p>It looks like this:</p>

<pre><code>H = hashfunction
H' = maps a hash into the group psuedorandomly.
x = password, or password hash.
k = server salt

g = generator in group
r = random element in group

# Client runs this
A = H'(x)*g^r

# Server calculates
v = g^k
b = A^k

# Client calculates the random-looking password
rwdU = H(x,v, b*v^{-r})

*Note*
b*v^{-r} = A^k * v^{-r} = (H'(x)*g^r)^k * (g^k)^{-r} = (H'(x)*g^rk) * (g^{-r}k} = H'(x)

# Which means that the correct password generates the same rwdU for every randomly selected r and correct server salt, k.
</code></pre>

<p>So the client is never exposed to the salt, and the server never learns the password.</p>

<h2 id="so-how-do-we-authenticate">So how do we authenticate?</h2>

<p>First a user needs to do a &ldquo;password registration&rdquo; at the server.</p>

<pre><code>pwdU = Client's password
privU, pubU = Client keys

kU = Server OPRF salt, random and independant of each user.
vU = g^kU
privS,pubS = Server keys. Can be the same for all users

# Client
rwdU = oprf(pwdU)
# Server also runs oprf but ignores the result.
oprf()

# Client
envelope = AuthEnc(rwdU, privU, pubU, pubS, vU)

# Client sends envelope and deletes rwdU, pwdU and keys.

# Server saves envelope
</code></pre>

<p>So the server has the encrypted envelope and kU. And the client has nothing saved.</p>

<p>Authentication can look like this:</p>

<pre><code>xU, yU = Client DH keys
xS, yS = Server DH keys

# Client
rwdU = oprf()

# Server
oprf()
signature = sign(privS, H(yU, yS))

# Client
decrypt envelope with rwdU
verified = verify(envelope(pubS), H(yU,yS))
signature = sign(envelope(privU), H(HKDF(dh_shared), envelope(pubU)))

# Server
verified = verify(pubU, H(HKDF(dh_shared), pub))
</code></pre>

<p>If the last verified check passes the client is authenticated, since it proves that the user knows the password.</p>

<h2 id="poc">PoC</h2>

<p>I&rsquo;ve implemented a simple server/client PoC <a href="https://github.com/ludvigknutsmark/OPAQUE_POC" target="_blank">here</a></p>

<p>This was a quick hack over two days, do not use this for anything important :-)</p>

<p>Next project is looking at security in some IoT-devices were given by a sponsor from BTH_CTF&hellip;</p>

<p>Until next time!</p>
]]></content>
		</item>
		
		<item>
			<title>Breaking AES GCM part 2</title>
			<link>https://ludvigknutsmark.github.io/posts/breaking_aes_gcm_part2/</link>
			<pubDate>Thu, 09 May 2019 16:08:35 +0200</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/breaking_aes_gcm_part2/</guid>
			<description>In the first part I discussed some background on why AES GCM exists. GCM stands for Galois Counter Mode. Now we will take a dive into the Galois part!
Galois Field Galois field, or finite field is a set in which the basic math operations are defined - addition, subtraction, multiplication and division. There is obviously a lot of rules for a field, but a major one is that the field must be isomorphic, i.</description>
			<content type="html"><![CDATA[

<p>In the first part I discussed some background on why AES GCM exists. GCM stands for Galois Counter Mode. Now we will take a dive into the Galois part!</p>

<h2 id="galois-field">Galois Field</h2>

<p>Galois field, or finite field is a set in which the basic math operations are defined - addition, subtraction, multiplication and division. There is obviously a lot of rules for a field, but a major one is that the field must be isomorphic, i.e all elements in the field must have an inverse. Therefore Galois Fields are only defined with the order of (number of elements) p. Where p is a prime or a prime power, p^k, where k is a positive integer.</p>

<h2 id="gcm-and-galois">GCM and Galois</h2>

<p>GCM works in GF(2^128) with the irreducible polynom.</p>

<pre><code>x^128+x^7+x^2+x+1
</code></pre>

<p>In a Galois Field the irreducible polynom is like a prime number, i.e it has no factors (in that field).</p>

<p>Here is a python implementation of addition, multiplication and division in GF(2^k).</p>

<pre><code># Returns the degree of the polynomial
def deg(a):
    deg = len(bin(a)[2:])-1
    return deg

# Add and subtract is the same. Since it's GF(2^k)
def add(a,b):
    return a^b

def divmod(a, b):
    q, r = 0, a

    while deg(r) &gt;= deg(b):
        d = deg(r) - deg(b)
        q = q ^ (1 &lt;&lt; d)
        r = r ^ (b &lt;&lt; d)

    return q, r

# Multiplicative over GF(2^k)
def gf_mul(a,b,m):
    # Peasant multiplication from wikipedia
    p = 0
    while a &gt; 0:
        if a &amp; 1:
            p = p^b
        
        a = a &gt;&gt; 1
        b = b &lt;&lt; 1
	
	# Modulus the polynomial m
        if deg(b) == deg(m):
            b = b^m

    return p
</code></pre>

<p>Now when we can do math in GF(2^k), let&rsquo;s implement the GHASH</p>

<h2 id="ghash">GHASH</h2>

<ol>
<li><p>Pick the MAC secret. Which is a block of zero bytes encrypted with your AES key.</p></li>

<li><p>Zero pad the ciphertext and additional data block by block, so it&rsquo;s divisible by the block length (AES-128=16). Then concatenate the blocks.</p></li>

<li><p>Add a block which concatenates the bit length of the ciphertext and AD.</p></li>

<li><p>For each of the concatenated blocks, do:</p>

<pre><code>tag += block
tag *= MAC secret
</code></pre></li>

<li><p>Mask the tag with a nonce-derived secret</p>

<pre><code>mask = AES(nonce || 1)
tag += mask
</code></pre></li>
</ol>

<p>Now you have derived a hash from the ciphertext, additional data, nonce and AES-key. Cool!</p>

<p>Here&rsquo;s my GHASH implemenation in Python3.</p>

<pre><code>import struct
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes, bytes_to_long

# The code shown above...
from galois import *

# GF(2^128)
# p = x^128+x^7+x^2+x+1

def convert_to_field_element(a):
    p = 340282366920938463463374607431768211591
    if deg(a) &gt;= deg(p):
        return a^p
    else:
        return a

class GHASH():
    def __init__(self, K, nonce, CT, AD=None):
        self.K = K
        self.nonce = nonce
        self.CT = CT
	self.AD = AD
        
	# MAC secret
        self.H = convert_to_field_element(bytes_to_long(self.E_K(b'\x00'*AES.block_size)))
        
        # Calculate Length block
        AD_len = 0 if AD==None else len(AD)
        len_block = struct.pack('&lt;Q', AD_len*8)+struct.pack('&lt;Q', len(CT)*8)
        # Pad CT and AD :-)
        self.pad()
        # Concatenate stuff
        self.data = self.CT+len_block if self.AD == None else self.AD+self.CT+len_block

    def E_K(self, data):
        cipher = AES.new(self.K)
        return cipher.encrypt(data)
    
    def pad(self):
        if len(self.CT) % AES.block_size != 0:
            self.CT = self.CT+b'\x00'*(AES.block_size-(len(self.CT) % AES.block_size))
        
        if self.AD != None:
            if len(self.AD) % AES.block_size != 0:
                self.AD = self.AD+b'\x00'*(AES.block_size-(len(self.AD) % AES.block_size))

    def round(self):
        g = 0
        for b in self.data:
            b = convert_to_field_element(bytes_to_long(b))
            g ^= b
            g = gf_mul(g,self.H,340282366920938463463374607431768211591)

        return g

    def derive(self):
        # Calculate the rounds
        g = self.round()

        # Mask tag
        s = bytes_to_long(self.E_K(self.nonce+struct.pack('&lt;i',4)))
        self.tag = g^s

        return self.tag
</code></pre>

<h3 id="tag-structure">Tag structure</h3>

<p>Basically what the tag looks like is this (MS is MAC secret):</p>

<pre><code>tag = (((((block1*MS)+block2)*MS)+len)*MS)+mask
</code></pre>

<p>Which becomes</p>

<pre><code>tag = block1*MS^3+block2*MS^2+len*MS+mask
</code></pre>

<h3 id="vulnerability">Vulnerability</h3>

<p>Now we know how the tag is calculated. Say that we accidentally repeat a nonce using the same AES key. What could possibly go wrong? Well, let&rsquo;s look at it.</p>

<pre><code>tag1 = b1*MS^3+b2*MS^2+len1*MS+mask

tag2 = d1*MS^3+d2*MS^2+len2*MS+mask
</code></pre>

<p>What do they have in common? MS, of course, since it&rsquo;s AES(key, &lsquo;\x00&rsquo;*block_length). What else?</p>

<p><strong>The mask!</strong></p>

<p>Since we work in GF(2^k) where addition and subtraction is the same, we can add the two tags together to remove the mask.</p>

<pre><code>tag1+2 = (b1^d1)*MS^3+(b2^d2)*MS^2+(len1^len2)*MS
</code></pre>

<p>The validation of the tag is that we plug in the mac secret into the polynomial and check if the result equals zero. So the mac secret is a root to tag.</p>

<pre><code>tag = f(MS) = 0
</code></pre>

<p>The attack is then to factor the polynomial tag1+2 to find the mac secret. If we find the MAC secret, we can fake the authentication tags for all ciphertexts under the same AES key.</p>

<p><img src="https://media.giphy.com/media/aWssxFetYLzIA/giphy.gif" alt="alt text" /></p>

<h3 id="next-post-will-be-to-implement-aes-gcm-factoring-tag1-2-and-successfully-fake-a-ciphertext">Next post will be to implement AES GCM, factoring tag1+2 and successfully fake a ciphertext.</h3>
]]></content>
		</item>
		
		<item>
			<title>Breaking AES GCM Part 1</title>
			<link>https://ludvigknutsmark.github.io/posts/breaking_aes_gcm_part1/</link>
			<pubDate>Sun, 05 May 2019 15:11:55 +0200</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/breaking_aes_gcm_part1/</guid>
			<description>This is a small three-part series where I will show some attacks and implementation of AES GCM, and why GCM is a good idea. Let&amp;rsquo;s get started!
Why does AES GCM exist? So it seems like AES is a bit complicated. Most people see AES and think - &amp;ldquo;Great! This can&amp;rsquo;t be broken&amp;rdquo;.
And sure, it isn&amp;rsquo;t feasible in any amount of time to get the key from a ciphertext, even when knowing the plaintext.</description>
			<content type="html"><![CDATA[

<p>This is a small three-part series where I will show some attacks and implementation of AES GCM, and why GCM is a good idea.
Let&rsquo;s get started!</p>

<h2 id="why-does-aes-gcm-exist">Why does AES GCM exist?</h2>

<p>So it seems like AES is a bit complicated. Most people see AES and think - &ldquo;Great! This can&rsquo;t be broken&rdquo;.</p>

<p>And sure, it isn&rsquo;t feasible in any amount of time to get the key from a ciphertext, even when knowing the plaintext. But there are other problems with the implemenation of AES. Let&rsquo;s look at the most basic mode of operation, AES ECB.</p>

<h3 id="ecb">ECB</h3>

<p>ECB, or Electronic Codebook is the simplest mode of operation. You divide the plaintext into blocks and encrypt the blocks separately.</p>

<p><img src="/AES_ECB.png" alt="image alt text" /></p>

<p>What&rsquo;s the problem with this? Two encrypted plaintexts will always be represented as the same ciphertext (if encrypted with the same key, of course).</p>

<h3 id="cbc">CBC</h3>

<p>Ok, ECB is bad. But what if we add another random element into the encryption of each block, so two encrypted plaintexts will not be represented as the same ciphertext. This seems like a good idea! Let&rsquo;s do it.</p>

<p><img src="/AES_CBC.png" alt="image alt text" /></p>

<p>CBC stands for Cipher Block Chaining, as the encryption of each block is dependant on the ciphertext from the previous block. This looks much better! But with this chaining comes other problems, like bitflipping attacks.</p>

<p>I&rsquo;ve written some code on a basic bitflipping attack <a href="https://raw.githubusercontent.com/ludvigknutsmark/Cryptopals_Solves/master/set2/challenge16.py" target="_blank">here</a>.
The basic idea of a bitflipping attack is that if the attacker know the plaintext, he/she can do some math to change the ciphertext into being decrypted into anything.
Oh, that&rsquo;s bad.</p>

<h3 id="ctr">CTR</h3>

<p>CTR stands for Counter. Instead of splitting the plaintext into blocks and padding it, we can have a counter with a random nonce (like IV) and XOR the &ldquo;keystream&rdquo; with the plaintext. This turns the AES block cipher into a stream cipher, which is a more logic way of looking at data. This is also suspectible to bitflipping attacks. <a href="https://raw.githubusercontent.com/ludvigknutsmark/Cryptopals_Solves/master/set4/challenge26.py" target="_blank">attack code</a>.</p>

<p>How do we fix this? By adding integrity checks of course! Which leads us perfectly into AES GCM.</p>

<h3 id="gcm">GCM</h3>

<p>GCM stands for Galois Counter Mode. This is bit more complex solution, since adding a simple hash after the ciphertext would fix nothing (since the attacker can modify the hash to the flipped code). GCM implements a type of <a href="https://en.wikipedia.org/wiki/Message_authentication_code" target="_blank">MAC</a>. This makes it near impossible for an attacker to fiddle with the ciphertext, since any change would be detected when comparing the hashes. And the attacker can&rsquo;t spoof the hash, since he/she doesn&rsquo;t know the secret.</p>

<p><img src="/AES_GCM.png" alt="image alt text" /></p>

<p>Some explanation:</p>

<ul>
<li>Auth Data 1: The Additional data which you can put into the GHASH function. GCM is an AEAD (Authenticated Encryption Additional Data) algorithm.</li>
<li>mult_H:. &ldquo;Each round&rdquo; of the GHASH function. The input data is multiplied with Ek(0^128) in a Galois Field (GF(2^128)).</li>
</ul>

<p>Galois field as a MAC is chosen because it actually allows the Auth Tag calculation to be computed in parallel, which makes it faster than for example CBC. And even more so, than a traditional SHA-1 MAC. And speed in cryptography is important.</p>

<h3 id="next-part-is-exploring-the-ghash-function">Next part is exploring the GHASH function</h3>
]]></content>
		</item>
		
		<item>
			<title>BTH_CTF{sM3ll_th3_sH3ll}</title>
			<link>https://ludvigknutsmark.github.io/posts/bthctf2019/</link>
			<pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/bthctf2019/</guid>
			<description>Hello, World! So, first ever post. Hope that I can keep this blog project going for quite some time atleast.
This weekend I (along with some classmates) organized our first ever CTF! It was amazing. We had so much fun, and so much work put into it. And it was so worth it. We had a total of 24 teams playing in our school overnight. Contestants from Dalarna, Linköping and of course our school.</description>
			<content type="html"><![CDATA[

<h2 id="hello-world">Hello, World!</h2>

<p>So, first ever post. Hope that I can keep this blog project going for quite some time atleast.</p>

<p>This weekend I (along with some classmates) organized our first ever CTF! It was amazing. We had so much fun, and so much work put into it. And it was so worth it.
We had a total of 24 teams playing in our school overnight. Contestants from Dalarna, Linköping and of course our school.</p>

<p>I was responsible for some of our crypto challenges, and some other (one reverse and two OSINT). I will be posting writeups for my challenges. Atleast those I released.</p>

<p>You can find pictures of the event <a href="https://photos.app.goo.gl/72aVV31mfduuJQ6G9" target="_blank">here</a>.</p>

<p>Huge thank you to our sponsors. SecureLink and IKEA!</p>
]]></content>
		</item>
		
	</channel>
</rss>
