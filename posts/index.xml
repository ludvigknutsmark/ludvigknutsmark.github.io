<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Thought for your thoughts</title>
		<link>https://ludvigknutsmark.github.io/posts/</link>
		<description>Recent content in Posts on Thought for your thoughts</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sun, 05 May 2019 15:11:55 +0200</lastBuildDate>
		<atom:link href="https://ludvigknutsmark.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Breaking AES GCM Part 1</title>
			<link>https://ludvigknutsmark.github.io/posts/breaking_aes_gcm_part1/</link>
			<pubDate>Sun, 05 May 2019 15:11:55 +0200</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/breaking_aes_gcm_part1/</guid>
			<description>This is a small two-part series where I will show some attacks and implementation of AES GCM, and why GCM is a good idea. Let&amp;rsquo;s get started!
Why does AES GCM exist? So it seems like AES is a bit complicated. Most people see AES and think - &amp;ldquo;Great! This can&amp;rsquo;t be broken&amp;rdquo;.
And sure, it isn&amp;rsquo;t feasible in any amount of time to get the key from a ciphertext, even when knowing the plaintext.</description>
			<content type="html"><![CDATA[

<p>This is a small two-part series where I will show some attacks and implementation of AES GCM, and why GCM is a good idea.
Let&rsquo;s get started!</p>

<h2 id="why-does-aes-gcm-exist">Why does AES GCM exist?</h2>

<p>So it seems like AES is a bit complicated. Most people see AES and think - &ldquo;Great! This can&rsquo;t be broken&rdquo;.</p>

<p>And sure, it isn&rsquo;t feasible in any amount of time to get the key from a ciphertext, even when knowing the plaintext. But there are other problems with the implemenation of AES. Let&rsquo;s look at the most basic mode of operation, AES ECB.</p>

<h3 id="ecb">ECB</h3>

<p>ECB, or Electronic Codebook is the simplest mode of operation. You divide the plaintext into blocks and encrypt the blocks separately.</p>

<p><img src="/AES_ECB.png" alt="image alt text" /></p>

<p>What&rsquo;s the problem with this? Two encrypted plaintexts will always be represented as the same ciphertext (if encrypted with the same key, of course).</p>

<h3 id="cbc">CBC</h3>

<p>Ok, ECB is bad. But what if we add another random element into the encryption of each block, so two encrypted plaintexts will not be represented as the same ciphertext. This seems like a good idea! Let&rsquo;s do it.</p>

<p><img src="/AES_CBC.png" alt="image alt text" /></p>

<p>CBC stands for Cipher Block Chaining, as the encryption of each block is dependant on the ciphertext from the previous block. This looks much better! But with this chaining comes other problems, like bitflipping attacks.</p>

<p>I&rsquo;ve written some code on a basic bitflipping attack <a href="https://raw.githubusercontent.com/ludvigknutsmark/Cryptopals_Solves/master/set2/challenge16.py" target="_blank">here</a>.
The basic idea of a bitflipping attack is that if the attacker know the plaintext, he/she can do some math to change the ciphertext into being decrypted into anything.
Oh, that&rsquo;s bad.</p>

<h3 id="ctr">CTR</h3>

<p>CTR stands for Counter. Instead of splitting the plaintext into blocks and padding it, we can have a counter with a random nonce (like IV) and XOR the &ldquo;keystream&rdquo; with the plaintext. This turns the AES block cipher into a stream cipher, which is a more logic way of looking at data. This is also suspectible to bitflipping attacks. <a href="https://raw.githubusercontent.com/ludvigknutsmark/Cryptopals_Solves/master/set4/challenge26.py" target="_blank">attack code</a>.</p>

<p>How do we fix this? By adding integrity checks of course! Which leads us perfectly into AES GCM.</p>

<h3 id="gcm">GCM</h3>

<p>GCM stands for Galois Counter Mode. This is bit more complex solution, since adding a simple hash after the ciphertext would fix nothing (since the attacker can modify the hash to the flipped code). GCM implements a type of <a href="https://en.wikipedia.org/wiki/Message_authentication_code" target="_blank">MAC</a>. This makes it near impossible for an attacker to fiddle with the ciphertext, since any change would be detected when comparing the hashes. And the attacker can&rsquo;t spoof the hash, since he/she doesn&rsquo;t know the secret.</p>

<p><img src="/AES_GCM.png" alt="image alt text" /></p>

<p>Some explanation:</p>

<ul>
<li>Auth Data 1: The Additional data which you can put into the G_HASH function. GCM is an AEAD (Authenticated Encryption Additional Data) algorithm.</li>
<li>mult_H: Is the Galois part. Is &ldquo;each round&rdquo; of the G_HASH function. The input data is multiplied with Ek(0^128) in a Galois Field (GF(2^128)).</li>
</ul>

<p>I won&rsquo;t explain the Galois Field more (it&rsquo;s a topic for another post), but the reason it&rsquo;s chosen is that it actually allows the Auth Tag calculation to be computed in parallel, which makes it faster than for example CBC. And even more so, than a traditional SHA-1 MAC. And speed in cryptography is important.</p>

<pre><code>import sys, struct, os

from Crypto.Cipher import AES

IRRED_COEFF = [
  4,3,1,5,3,1,4,3,1,7,3,2,5,4,3,5,3,2,7,4,2,4,3,1,10,9,3,9,4,2,7,6,2,10,9,
  6,4,3,1,5,4,3,4,3,1,7,2,1,5,3,2,7,4,2,6,3,2,5,3,2,15,3,2,11,3,2,9,8,7,7,
  2,1,5,3,2,9,3,1,7,3,1,9,8,3,9,4,2,8,5,3,15,14,10,10,5,2,9,6,2,9,3,2,9,5,
  2,11,10,1,7,3,2,11,2,1,9,7,4,4,3,1,8,3,1,7,4,1,7,2,1,13,11,6,5,3,2,7,3,2,
  8,7,5,12,3,2,13,10,6,5,3,2,5,3,2,9,5,2,9,7,2,13,4,3,4,3,1,11,6,4,18,9,6,
  19,18,13,11,3,2,15,9,6,4,3,1,16,5,2,15,14,6,8,5,2,15,11,2,11,6,2,7,5,3,8,
  3,1,19,16,9,11,9,6,15,7,6,13,4,3,14,13,3,13,6,3,9,5,2,19,13,6,19,10,3,11,
  6,5,9,2,1,14,3,2,13,3,1,7,5,4,11,9,8,11,6,5,23,16,9,19,14,6,23,10,2,8,3,
  2,5,4,3,9,6,4,4,3,2,13,8,6,13,11,1,13,10,3,11,6,5,19,17,4,15,14,7,13,9,6,
  9,7,3,9,7,1,14,3,2,11,8,2,11,6,4,13,5,2,11,5,1,11,4,1,19,10,3,21,10,6,13,
  3,1,15,7,5,19,18,10,7,5,3,12,7,2,7,5,1,14,9,6,10,3,2,15,13,12,12,11,9,16,
  9,7,12,9,3,9,5,2,17,10,6,24,9,3,17,15,13,5,4,3,19,17,8,15,6,3,19,6,1]

def getpoly(deg):
  if deg &amp; 7 != 0 or deg &lt; 8 or deg &gt; 1024: raise Exception('Not supported Degree')
  x = int(deg / 8 - 1)
  return (1&lt;&lt;IRRED_COEFF[3*x]) + (1&lt;&lt;IRRED_COEFF[3*x + 1]) + (1&lt;&lt;IRRED_COEFF[3*x + 2]) + 1

def gmul(a, b, deg=8):
  poly = getpoly(deg)
  max_1 = (1&lt;&lt;deg) - 1
  max_2 = 1&lt;&lt;(deg - 1)
  z = 0
  if a &amp; 1:
    r = b
  else:
    r = 0
  for i in range(1,deg+1):
    mark = b &amp; max_2
    b = (b &lt;&lt; 1) &amp; max_1
    if mark: # Note: not really protected by timing attack. since...
      b ^= poly
    else:
      b ^= z
    # print a &amp; (1 &lt;&lt; i), r, b
    if a &amp; (1 &lt;&lt; i):
      r ^= b
    else:
      r ^= z
  return r

def XOR(arr1, arr2):
    # Ugly solution
    if isinstance(arr1, bytes):
        return ''.join(chr(a ^ ord(b)) for a,b in zip(arr1,arr2))
    else:
        return ''.join(chr(ord(a) ^ ord(b)) for a,b in zip(arr1,arr2))

# For two byte strings
def b_XOR(b1,b2):
    return ''.join(chr(a^b) for a,b in zip(b1,b2))

class aes_gcm():
    def __init__(self, key, iv, AD):
        self.key = key
        self.iv = iv
        self.AD = AD
        
        self.EK = AES.new(self.key)
        self.H = self.EK.encrypt(self.iv+struct.pack('&lt;Q', 0))
        
    def reset(self):
        self.tag = self.MULT_H(self.AD)
        self.count = 1

    def stream(self, src_blocks):
        dst_blocks = []
        for src in src_blocks:
            counter = struct.pack('&lt;Q',self.count)
            dst_blocks.append(XOR(self.EK.encrypt(self.iv+counter), src))
            self.count += 1

        return ''.join(dst_blocks)
    
    def encrypt(self,plaintext):
        # Reset the variables
        self.reset()
        plaintext_blocks = self.create_blocks(plaintext)
        ciphertext = self.stream(plaintext_blocks)
        
        # Calculate the authentication tag
        ciphertext_blocks = self.create_blocks(ciphertext)
        auth_tag = self.G_HASH(ciphertext_blocks)

        return ciphertext+auth_tag

    def decrypt(self,ciphertext):
        # Reset the variables
        self.reset()

        # Validate the Authentication tag
        auth_tag = ciphertext[-16:]
        ciphertext_blocks = self.create_blocks(ciphertext[:-16])
        if auth_tag != self.G_HASH(ciphertext_blocks):
            raise ValueError(&quot;Integrity check failed!&quot;)
        
        return self.stream(ciphertext_blocks)

    def create_blocks(self, src):
        dst = []
        for i in range(len(src)//AES.block_size):
            dst.append(src[i*AES.block_size:(i+1)*AES.block_size])
        
        if (len(src) % 16) != 0:
            dst.append(src[-(len(src)%16):])

        return dst

    def G_HASH(self, ciphertext_blocks):
        for CT in ciphertext_blocks:
            # Calculate the data for the mult_h
            b_CT = str.encode(CT)
            data = b_XOR(b_CT, self.tag)
            self.tag = self.MULT_H(data)

        # Finish the tag-calculation
        data_len = struct.pack('&lt;Q', len(self.AD))+struct.pack('&lt;Q', len(ciphertext_blocks)*AES.block_size)
        data = b_XOR(data_len, self.tag)
        self.tag = self.MULT_H(data)
        AUTH_TAG = b_XOR(self.H, self.tag)
        
        return AUTH_TAG
        
    def MULT_H(self, data):
        if not isinstance(data,bytes):
            try:
                data = str.encode(data)
            except:
                raise ValueError(&quot;Data can not be represented as bytes&quot;)

        # Pre-calc ints to GF calculation
        H = int.from_bytes(self.H, sys.byteorder)
        d = int.from_bytes(data, sys.byteorder)
        GM = gmul(d,H,128)
        return GM.to_bytes((GM.bit_length()+7)//8, sys.byteorder)

</code></pre>

<p>The Galois part is borrowed since I couldn&rsquo;t find any library support for it in python. One improvement to the code would be to thread the G_HASH calculation, or to embed it in the stream calculation for the encryption routine.</p>

<h3 id="next-part-is-breaking-gcm">Next part is breaking GCM</h3>
]]></content>
		</item>
		
		<item>
			<title>BTH_CTF{sM3ll_th3_sH3ll}</title>
			<link>https://ludvigknutsmark.github.io/posts/bthctf2019/</link>
			<pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
			
			<guid>https://ludvigknutsmark.github.io/posts/bthctf2019/</guid>
			<description>Hello, World! So, first ever post. Hope that I can keep this blog project going for quite some time atleast.
This weekend I (along with some classmates) organized our first ever CTF! It was amazing. We had so much fun, and so much work put into it. And it was so worth it. We had a total of 24 teams playing in our school overnight. Contestants from Dalarna, Linköping and of course our school.</description>
			<content type="html"><![CDATA[

<h2 id="hello-world">Hello, World!</h2>

<p>So, first ever post. Hope that I can keep this blog project going for quite some time atleast.</p>

<p>This weekend I (along with some classmates) organized our first ever CTF! It was amazing. We had so much fun, and so much work put into it. And it was so worth it.
We had a total of 24 teams playing in our school overnight. Contestants from Dalarna, Linköping and of course our school.</p>

<p>I was responsible for some of our crypto challenges, and some other (one reverse and two OSINT). I will be posting writeups for my challenges. Atleast those I released.</p>

<p>You can find pictures of the event <a href="https://photos.app.goo.gl/72aVV31mfduuJQ6G9" target="_blank">here</a>.</p>

<p>Huge thank you to our sponsors. SecureLink and IKEA!</p>
]]></content>
		</item>
		
	</channel>
</rss>
